<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Engine - Locked Tracking & Zoom</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute; top: 20px; left: 20px; color: white;
            pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        #status-pill {
            display: inline-block; padding: 5px 15px; border-radius: 20px;
            background: rgba(0, 242, 255, 0.2); border: 1px solid #00f2ff;
            font-weight: bold; margin-top: 10px; transition: all 0.3s;
        }
        #video-container { 
            position: absolute; bottom: 20px; right: 20px; 
            width: 180px; height: 135px; border: 2px solid #00f2ff; 
            border-radius: 10px; overflow: hidden; opacity: 0.4; 
        }
        video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    </style>
</head>
<body>
    <div id="info">
        <h1 style="color: #00f2ff; margin: 0; letter-spacing: 2px;">DYNAMIC LOCK ENGINE</h1>
        <p>‚úä <b>Fist:</b> LOCK Shape | üñêÔ∏è <b>Open Palm:</b> UNLOCK</p>
        <p>üîí <b>When Locked:</b> Hand movement moves shape | Pinch to Zoom</p>
        <div id="status-pill">STATUS: ACTIVE</div>
    </div>

    <div id="video-container"><video id="input-video" playsinline></video></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform float uMorph; 
        uniform int uState;
        attribute vec3 pos1, pos2, pos3, pos4;
        attribute float aRandom;
        varying vec3 vColor;

        void main() {
            vec3 target;
            if(uState == 1) target = pos1;
            else if(uState == 2) target = pos2;
            else if(uState == 3) target = pos3;
            else if(uState == 5) target = pos4; // Heart
            else target = position;             // Sphere

            vec3 mixedPos = mix(position, target, uMorph);
            float dissolve = sin(uMorph * 3.14159);
            vec3 jitter = vec3(sin(uTime * 3.0 + aRandom), cos(uTime * 2.5 + aRandom), sin(uTime * 4.0 + aRandom)) * aRandom * dissolve * 0.5;
            vec3 finalPos = mixedPos + jitter;

            float split = clamp(finalPos.x * 0.2 + 0.5, 0.0, 1.0);
            vec3 colorCyan = vec3(0.0, 0.95, 1.0);
            vec3 colorPurple = vec3(0.8, 0.4, 1.0);
            vColor = mix(colorPurple, colorCyan, split);
            
            vec4 mvPos = modelViewMatrix * vec4(finalPos, 1.0);
            gl_PointSize = 3.5 * (20.0 / -mvPos.z);
            gl_Position = projectionMatrix * mvPos;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vColor;
        void main() {
            if (distance(gl_PointCoord, vec2(0.5)) > 0.5) discard;
            gl_FragColor = vec4(vColor, 1.0);
        }
    </script>

    <script>
        const PARTICLE_COUNT = 15000;
        let scene, camera, renderer, material, pointsObj;
        let targetState = 0; 
        let isLocked = false;
        let baseZoom = 25;

        // Configuration for tracking
        const lerpAmount = 0.1;
        let targetPos = new THREE.Vector3(0, 0, 25);

        function generateShapes() {
            const p1 = [], p2 = [], p3 = [], p4 = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                const offset = (Math.random() - 0.5) * 1.2;
                // Torus
                const r1 = 6 + Math.cos(3 * t);
                p1.push(r1 * Math.cos(2 * t), r1 * Math.sin(2 * t), -Math.sin(3 * t) + offset);
                // Star
                const r2 = 6 + 2 * Math.sin(5 * t);
                p2.push(r2 * Math.cos(t), r2 * Math.sin(t), Math.sin(10 * t) * 0.5 + offset);
                // Cube
                const side = (i % 3);
                const val = (Math.random() > 0.5 ? 6 : -6);
                const rand = (Math.random() - 0.5) * 12;
                if(side === 0) p3.push(val, rand, (Math.random() > 0.5 ? 6 : -6));
                else if(side === 1) p3.push(rand, val, (Math.random() > 0.5 ? 6 : -6));
                else p3.push((Math.random() > 0.5 ? 6 : -6), rand, val);
                // Heart
                const hx = 16 * Math.pow(Math.sin(t), 3);
                const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                p4.push(hx * 0.5, hy * 0.5, (Math.random() - 0.5) * 1.5);
            }
            return { p1, p2, p3, p4 };
        }

        async function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = baseZoom;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const shapes = generateShapes();
            const geo = new THREE.BufferGeometry();
            const sphereArr = new Float32Array(PARTICLE_COUNT * 3);
            const randoms = new Float32Array(PARTICLE_COUNT);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                sphereArr[i*3] = 9 * Math.cos(theta) * Math.sin(phi);
                sphereArr[i*3+1] = 9 * Math.sin(theta) * Math.sin(phi);
                sphereArr[i*3+2] = 9 * Math.cos(phi);
                randoms[i] = Math.random() * 4.0;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(sphereArr, 3));
            geo.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
            geo.setAttribute('pos1', new THREE.Float32BufferAttribute(shapes.p1, 3));
            geo.setAttribute('pos2', new THREE.Float32BufferAttribute(shapes.p2, 3));
            geo.setAttribute('pos3', new THREE.Float32BufferAttribute(shapes.p3, 3));
            geo.setAttribute('pos4', new THREE.Float32BufferAttribute(shapes.p4, 3));

            material = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uState: { value: 0 } },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
            });
            
            pointsObj = new THREE.Points(geo, material);
            scene.add(pointsObj);
            initTracking();
            animate();
        }

        function initTracking() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
                    const lm = results.multiHandLandmarks[0];
                    const f8 = lm[8].y < lm[6].y; const f12 = lm[12].y < lm[10].y;
                    const f16 = lm[16].y < lm[14].y; const f20 = lm[20].y < lm[18].y;
                    const thumb = lm[4].x < lm[3].x;
                    const count = [f8, f12, f16, f20].filter(x => x).length;

                    const isFist = count === 0 && lm[8].y > lm[6].y;
                    const isFive = count === 4 && thumb;

                    // LOCK/UNLOCK LOGIC
                    if (isFist && !isLocked) {
                        isLocked = true;
                        document.getElementById('status-pill').innerText = "STATUS: LOCKED (MOVE & ZOOM)";
                        document.getElementById('status-pill').style.borderColor = "#ff2d55";
                    } else if (isFive && isLocked) {
                        isLocked = false;
                        // Reset position to center on unlock
                        targetPos.x = 0; targetPos.y = 0;
                        document.getElementById('status-pill').innerText = "STATUS: ACTIVE";
                        document.getElementById('status-pill').style.borderColor = "#00f2ff";
                    }

                    if (isLocked) {
                        // POSITION TRACKING (Mapped to screen space)
                        // Landmark 9 is the middle of the palm
                        const palmX = (lm[9].x - 0.5) * -30; // Inverse X for mirroring
                        const palmY = (lm[9].y - 0.5) * -22; // Inverse Y for matching movement
                        targetPos.x = palmX;
                        targetPos.y = palmY;

                        // ZOOM LOGIC
                        const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                        targetPos.z = 45 - (dist * 60); 
                    } 
                    else {
                        let newState = targetState;
                        if (isFive) newState = 5; 
                        else if (count === 4 && !thumb) newState = 0; 
                        else if (count >= 1 && count <= 3) newState = count;

                        if (newState !== targetState) {
                            material.uniforms.uMorph.value = 0;
                            targetState = newState;
                        }
                    }
                }
            });

            new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 }).start();
        }

        function animate(time) {
            requestAnimationFrame(animate);
            material.uniforms.uTime.value = time * 0.001;
            material.uniforms.uState.value = targetState;
            material.uniforms.uMorph.value += (1.0 - material.uniforms.uMorph.value) * 0.06;
            
            // Smoothly move the object to the hand position
            pointsObj.position.lerp(new THREE.Vector3(targetPos.x, targetPos.y, 0), lerpAmount);
            // Smoothly move camera for zoom
            camera.position.z += (targetPos.z - camera.position.z) * lerpAmount;
            
            pointsObj.rotation.y += 0.005;
            renderer.render(scene, camera);
        }

        initThree();
    </script>
</body>
</html>